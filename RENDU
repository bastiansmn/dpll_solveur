                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 29 octobre 2021, 23h59

Identité
--------
Nombre de binôme: 47
Nom, prénom 1: SEDDIKI Bilal
Nom, prénom 2: SOMON Bastian


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

**à remplir**

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

**à remplir**

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

**à remplir**

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Nous avons utilisé la fonction auxiliaire `flatten` qui permet de linéariser les clauses données (c'est à dire de rendre la int list list -> int list).
Cette fonction s'exécute en temps linéaire en le nombre de littéraux totaux.
Ensuite nous avons écrit une fonction `is_pur` parcourant toute la liste linéarisé, telle que on regarde si le littéral x courant existe sous la forme -x, alors renvoie None (pas de littéral), et si on arrive à la fin de la liste sans qu'il n'existe x et -x, alors renvoie Some(x).
Dès lors il suffit d'appeler `is_pur (flatten clauses)`.

Cette implémentation a un coût quadratique.

Il est possible de réaliser cette fonction en temps linéaire grâce aux Hashtbl de Ocaml. On parcours la liste renvoyée par `flatten clauses` pour mapper dans la table (de même longueur que la liste) chaque littéraux avec son nombre d'occurence. Cette opération peut se faire en temps linéaire. Puis on parcours la Hashtbl (où il n'y aura pas eu de collision par construction) pour voir si il existe un x tq h(x) >= 1 et h(-x) = 0. Ceci ce fait en temps au pire linéaire.
Donc on aura bien un algorithme en temps linéaire. Le problème étant que cette solution était trop compliqué à implémenter dans un langage récent pour nous comme Ocaml.

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

**à remplir**

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--